"""
Большие данные
Ограничение времени	1 секунда
Ограничение памяти	512Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Решение, проходящее все тесты, будет оценено в 3 балла.

Даны массив  a длины n, и массив b длины m. Все элементы обоих массивов — цифры от 0 до 9 включительно.
Составим по этим массивам таблицу c размера n×m, где элемент в i-й строке и j-м столбце определяется формулой
c(i,j)=a(i)⋅10**9+b(j). Рассмотрим всевозможные пути из клетки c(1,1) в клетку c(n,m)
, состоящие только из перемещений вниз и вправо (то есть, из клетки c(i,j) можно переходить только в клетки c(i+1,j)
и c(i,j+1), если эти клетки находятся внутри таблицы).
Среди всех этих путей выберите такой, что сумма чисел в посещённых клетках максимальна, и выведите эту сумму.

Формат ввода
Первая строка содержит два целых числа n и m — размеры массивов a и b соответственно (1≤n,m≤100000).
Во второй строке записано n целых чисел a1,…,an (0≤ai≤9).
Во третьей строке записано m целых чисел b1,…,bm (0≤bj≤9).

Формат вывода
Выведите одно число — максимальную сумму чисел в клетках среди путей в таблице c, удовлетворяющих правилам выше.
"""

"""
Логика программы построена на том, что максимальный путь будет из первой точки до первой максимальной строки
потом до первого максимального столбца, потом до последней МАКСИМАЛЬНОЙ строки(если такая есть),
потом из неё до последнего столбца(вправо) и до упора вниз
"""

massive_size = input()  # Получаем из ввода количество строк и столбцов в виде 7 4
massive_size = massive_size.split()  # Разделяем ввод через пробел, получаем [7,4]
massive_a_size = int(massive_size[0])  # Записываем количество строк
massive_b_size = int(massive_size[1])  # Записываем количество столбцов
massive_a = input()  # Получаем из ввода значения строк в виде 0 7 1 7 6 7 6
massive_a = massive_a.split()  # Разделяем ввод через пробел, получаем [0,7,1,7,6,7,6]
massive_b = input()  # Получаем из ввода значения столбцов в виде 4 1 9 7
massive_b = massive_b.split()  # Разделяем ввод через пробел, получаем [4,1,9,7]


def check_for_equal():
    """
    Функция проверяет матрицу на ситуацию, когда все столбцы и строки равны одной и той же цифре
    Например [1, 1, 1, 1] [1, 1, 1]
    :return: Функция возвращает в случае если все равны - сумму самого ценного пути и True для триггера
    Если же значения отличаются - вернет 0 и False для триггера
    """
    strings_unique = set(massive_a)  # СЕТ уникальных строк в массиве а(строки) пример [0,7,1,6]
    columns_unique = set(massive_b)  # СЕТ уникальных строк в массива б(столбцы) пример [4,1,9,7]
    if len(strings_unique) == 1 and len(
            columns_unique) == 1:  # Если длина обоих сетов равна 1, значит все значения равны
        default = int(massive_a[0]) * (10 ** 9) + int(massive_b[0])  # Дефолтное значение ячейки по формуле
        total_sum = (default * len(massive_a)) + (default * (len(massive_b) - 1))  # Считаем сумму всей таблицы
        return total_sum, True
    else:
        return 0, False


def find_index_for_max_values(massive, index):
    """
    Функция ищет и записывает ИНДЕКСЫ всех максимальных значений в столбцах либо строках
    :param massive: На вход принимает список значений столбцов/строк
    :param index: И индекс первого максимального значения для поиска соответствий
    :return:  Функция возвращает список индексов всех максимальных значений для введенного массива данных
    """
    max_value = massive[int(index)]  # Записываем первое максимальное значение
    list_of_max_values_indexes = []  # Создаем список для индексов максимальных значений
    for i in range(len(massive)):  # Перебираем все значения в списке строк или столбцов
        if massive[i] == max_value:  # Если нашли совпадение
            list_of_max_values_indexes.append(i)  # Записываем индекс очередного максимального значения
    return list_of_max_values_indexes


def find_max_summ():
    """
    Главная функция программы, которая суммирует ценность клеток и проходит путь по логике описанной выше
    :return: Функция возвращает значение суммы пути
    """
    total_sum = 0  # Создаем переменную для подсчета суммы пути
    stop_row_index = massive_a.index(max(massive_a))  # Записываем индекс первой максимальной строки
    stop_column_index = massive_b.index(max(massive_b))  # Записываем индекс первого максимального столбца
    index_of_stop_rows = find_index_for_max_values(massive_a, stop_row_index)  # Записываем список индексов максимальных строк
    i = 0  # Задаем счетчик строк i равным нулю
    j = 0  # Задаем счетчик столбцов j равным нулю
    for step in range(len(index_of_stop_rows)):  # Перебираем список индексов максимальных строк
        stop_row_index = index_of_stop_rows[step]  # Задаем значение индекса стоп строки
        while i != stop_row_index:  # Пока не доберемся до следующей максимальной строки
            total_sum += int(massive_a[i]) * 10 ** 9 + int(massive_b[j])  # Суммируем путь
            i += 1  # Увеличиваем счетчик строк на 1
        while j != stop_column_index:  # Пока не доберемся до следующего максимального столбца
            total_sum += int(massive_a[i]) * 10 ** 9 + int(massive_b[j])  # Суммируем путь
            j += 1  # Увеличиваем счетчик столбцов на 1
    if stop_column_index == j and stop_row_index == i:  # Если в результате перебора добрались до последней максимальной строки и столбца
        while j != len(massive_b):  # Пока не доберемся до ПОСЛЕДНЕГО столбца (путь вправо)
            total_sum += int(massive_a[i]) * 10 ** 9 + int(massive_b[j])  # Суммируем путь
            j += 1  # Увеличиваем счетчик столбцов на 1
        j -= 1  # Как только дошли до крайнего столбца уменьшаем счетчик столбцов на 1
        i += 1  # Увеличиваем счетчик строк на 1
        while i != len(massive_a):  # Пока не дойдем до крайней строки (путь вниз)
            total_sum += int(massive_a[i]) * 10 ** 9 + int(massive_b[j])  # Суммируем путь
            i += 1  # Увеличиваем счетчик строк на 1
        return total_sum


def run():
    """
    Функция запуска отдельных функций программы
    :return: Функция ничего не возвращает
    """
    total_sum_from_equal, equal = check_for_equal()  # Проверяем ситуацию с одинаковыми значениями столбиков/строк
    if equal:  # Если значения столбиков/строк одинаковые - выводим сумму пути
        print(total_sum_from_equal)
        return
    else:  # Если значения строк/столбцов разные - запускаем функцию поиска выгодного пути
        total_sum = find_max_summ()
    print(total_sum)


run()
